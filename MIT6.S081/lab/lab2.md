开幕雷击！竟然还要我读Section 4.3 and 4.4 of Chapter 4.

现在这做笔记吧！等做到4再移过去

## 4.3	Code: Calling system calls

和刚更新的笔记一致：用户代码将`exec`的参数放在寄存器`a0`和`a1`中，并将系统调用号放在`a7`中。系统调用号与`syscalls`数组中的条目相匹配（`syscalls`数组是一个函数指针表 (kernel/syscall.c:108)）。

## 4.4	Code: System call arguments

一节讲函数调用，一节讲调用的参数

内核中的系统调用接口需要找到用户代码传递的参数。因为用户代码调用系统调用封装函数，所以参数只能通过放置在RISC-V C调用所约定的位置：寄存器来传递给内核。

内核trap代码将用户寄存器保存到当前进程的`trapframe`中，内核代码可以在其中找到它们。（和read-xv6-2分析的一样）

函数`argint`、`argaddr`和`argfd`从`trapframe`中检索第`n`个系统调用参数作为整数、指针或文件描述符。它们都调用`argraw`来检索相应的的已保存的用户寄存器(kernel/syscall.c:35)。 

这里提到说xv6内核页表映射与用户页表映射不同，因此内核不能使用普通指令从用户提供的地址加载或存储。 

> Q：为什么二者不同？
>
> 在gpt给出的解释中：内核页表是在内核初始化时就创建并初始化好的，而用户页表则是在进程创建时动态分配并初始化的。这两个页表分别对应着不同的页目录和页表，在不同的地址空间中。虽然 `mappages` 函数被用来映射用户空间和内核空间的页表，但是它们所映射的实际上是不同的物理页，而且这些页被映射到不同的虚拟地址上。这就是为什么说 xv6 中的内核页表和用户页表是不同的原因。

后面谈到了内核实现了安全地将数据传入和传出用户提供的地址和功能，例子`fetchstr`、`copyinstr`、`walkaddr`、`copyout`等函数，在trans-4都有详解。

## lab

回到实验中，