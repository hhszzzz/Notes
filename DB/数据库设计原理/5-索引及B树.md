# 索引及B树

数据库中数据记录以==**线性表**==的形式存放，每一个记录都有指向下一个记录的指针，多个记录存放在一个页中。

![image-20230522195138909](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230522195138909.png)

如果用遍历的方式查找，那就是从每页的记录，逐个查找下去，知道查完所有的页，这样的查询效率是`O(n)`。

由此引出**索引**，首先要对数据进行排序（如果是数值，就直接排序，如果排序的内容是文本，那么采用字典排序），再利用二分查找。

> 索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。**简单来说，索引就像书的目录， 通过书的目录就准确的定位到了书籍具体的内容**

- 带着问题边看边思考

（1）为什么要给表加上主键？

（2）为什么加索引后会使查询变快？

（3）为什么加索引后会使写入、修改、删除变慢？

（4）什么情况下要同时在两个字段上建索引？

## B树

平衡二叉树查找效率比非平衡二叉树要高，但是平衡结构发生改变时，需要时间进行调整

$\displaystyle查找次数=log_{树的分叉数}^{记录总数}$，想要提升查询效率，需要增加**树的分叉数**。

下图是一个3阶B树

![image-20230522200725944](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230522200725944.png)

假设查询`id=8`的记录，会发生三次`IO`，按照二分查找，分别将磁盘块1、磁盘块2、磁盘块6加载到内存，最后找到8，结束查询。

**所以使用索引会使数据查找效率得到显著的提升**

## 索引

### 一、索引的表示形式

一条索引记录中包含的基本信息包括：**键值**（即你定义索引时指定的所有字段的值）+**逻辑指针**（指向数据页或者另一索引页）。

下面是一个聚集索引<span name="img">图例</span>

![image-20230522201056158](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230522201056158.png)

当查003的时候，会从001->001->数据块，再从数据块中顺序查找，直到找到003号

### 二、索引的类型

（1）聚集索引

> 表数据按照索引的顺序来存储的。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。

- 姓名作为聚集索引字段

![image-20230522201519448](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230522201519448.png)

上图可以看出，最终的数据表是存储了真实的数据，当查询到姓名为dull时，就直接返回真实数据。

如下图：

![image-20230522202045588](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230522202045588.png)

（2）非聚集索引

> 表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，该层紧邻数据页，其行数量与数据表行数据量一致。

- id作为聚集索引字段，姓名作为非聚集索引字段

![image-20230522201737542](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230522201737542.png)

在上图中可以观察到，`data page`中并不是按照姓名来顺序存储的，而是`id`。

当查找姓名dull时，找到的并不是真实的数据（可以理解为叶子节点存储的还是索引），想要查找到最终的真实数据，还需要回到聚集索引字段`id`的B树中进行查找，才能找到最终的数据。

如下图：

![image-20230522202213580](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230522202213580.png)

通过`name`索引最终只能查出数据的主键，然后再按主键将其他所需要的数据查询出来，这个过程称为**回表**。

### 三、索引的语法

（1）创建索引：

`create index 索引名称 on tablename (column1 [, column2, ... , columnN])`

（2）删除索引：

`drop index 索引名称 on tablename`

### 四、索引的存储和读取方式

> 一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟认知中的==「表」==很接近。

 ![image-20230522203444945](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230522203444945.png)

如果查找第n个数据，则需要查找n次

>
> 如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的==「平衡树」==结构。也就是所谓的==「聚集索引」==。

![image-20230522203551881](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230522203551881.png)

> 这就是为什么一个表只能有一个主键， 一个表只能有一个==「聚集索引」==，因为主键的作用就是把==「表」==的数据格式转换成==「索引（平衡树）」==的格式放置。
>
> （回答第四章问题：为什么MySQL数据库要求表中一定要有主键？）

### 五、聚集索引

>下图就是带有主键的表（聚集索引）的结构图。其中树的所有结点（底部除外）的数据都是由主键字段中的数据构成，叶子节点是真正表中的数据。这里我们指定主键为`id`。 

![image-20230522203631024](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230522203631024.png)

- 索引的局限

  ① 如果查询返回的结果太多，效率也会低下，因此查询要避免返回大量的结果，查询返回记录数量可以用`limit`控制

  ② 查询条件是计算式或函数时，聚集索引不起作用，查询将非常慢

### 六、非聚集索引

> 非聚集索引也是一种B+树，也可以起到快速检索的作用，但利用非聚集索引的查询由两次查询组成：
>
> （1）第一次查询非聚集索引的B+树，得到对应的聚集索引值；
>
> （2）第二次查询根据第一次查询得到的聚集索引值，在聚集索引的B+树进行查找，得到对应的记录。

举例：在表order_table的上架单字段创建了非聚集索引，查询语句如下：

```sql
 SELECT *  from order_table2 WHERE `上架单`='UP2009042645';
```

其查找过程是这样的，见下图：

![image-20230522204800630](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230522204800630.png)

- 重复率高的字段不适合作为非聚集索引

  因为要查询到数据，如果从100万行数据中取50万行数据（如性别），首先要根据非聚集索引查找到对应的聚集索引的值，再根据聚集索引的值访问真实的值（回表），这样效率不如进行一次完整扫描，甚至更低。

  **当非聚集索引回表的数量太多时，索引相当于没有**

### 七、索引导致查询以外的性能降低（有前提）

> 事物具有两面性，虽然索引能提升数据库**查询**效率， 但会导致**查询以外**的效率降低。原因很简单， 因为B+树是一个**平衡**树，这个结构必须一直维持在一个平衡的状态， **批量的增删改数据**都会改变平衡树各节点中的索引节点，导致B+树不平衡。
>
> 
>
> 因此，在当B+树出现不平衡状态时， DBMS必须去**重新梳理B+树（索引）的结构（树的左旋、右旋）以确保它的正确**，如果需要调整的节点**太多**时，会导致系统产生较大的性能开销，也就是为什么索引对导致查询以外的操作变慢的原因。
>
> 注意核心是：需要调整的节点**太多**，如果仅修改几行，那么该树甚至可能不会改变结构

- 两个结论

>两个结论：
>
>（1）索引越多，查询以外的性能就越差。（B+树维护其平衡状态需要大量CPU计算）
>
>（2）如果仅有聚集索引，那么查询以外的性能几乎不受影响。

- 解释结论（2）

>（第四章 主键的第2个问题，为什么建议使用与业务无关的自增ID作为主键？）
>
>MySQL的聚集索引数据记录被存于B+Tree的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按聚集索引的值顺序存放，每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。
>
><a href="#img">例子</a>中，物理块可能还会有剩余
>
>而批量插入数据往往是连续的，这时对于聚集索引而言，需要调整的不多；但对于非聚集索引而言，每个数据的位置都是随机的，所以可能调整的节点就非常多。
>
>**如果用自增主键，那么效果会更好，因为每次插入的数据都是在最后的叶子节点。**

- 对空间的影响

>此外，索引还会增加数据库的存储空间，这是因为每增加一个索引，就要产生一个索引字段的B树，字段中的数据就会被额外复制一份，索引越多，增加的存储空间越大；而且随着数据量的增大，索引数量越多，存储代价越大。

- 总结

>总结，虽然索引可以提升查询的效率，但是也会导致批量数据插入、删除的性能急剧下降。<u>**所以，当数据量超过百万级别的时候，创建非聚集索引要谨慎再谨慎，不能只以查询性能为判断依据，同时要考虑写入数据的性能。**</u>

### 八、复合索引