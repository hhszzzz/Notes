# 结构化查询语句

## 结构化查询语句的类别

![image-20230327145038201](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230327145038201.png)

## 数据定义语句DDL

### 数据类型

- 数值类型

  ![image-20230327151219071](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230327151219071.png)

- 时间类型

  ![image-20230327151251257](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230327151251257.png)

  > 一般使用`TIMESTAMP`

- 字符类型

  ![image-20230327152017593](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230327152017593.png)

  > `varchar`语法：`VARCHAR(255)`括号内的数字表示的是最大长度。

### 约束Constraint

> 目的：保证表中的记录完整和有效性

![image-20230327153720143](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230327153720143.png)

#### 约束声明的两种方式

> 1）表级约束：对**多个数据列**建立的约束，表级约束只能在列定义后
>
> ```mysql
> create table t_user(
>      id int(10),
>      name varchar(32) unique
> );
> ```
>
> 2）列级约束：对**一个数据列**建立的约束，列级约束在列定义中
>
> ```mysql
> create table t_user(
>     id int(10),
>     email varchar(128),
>     constraint email_unique unique(email)
> );
> ```
>
> 注意第4行的`constraint email_unique`可写可不写（建议写），不写会给一个默认的约束名称。
>
> - 所有的约束都可以用于列级约束，但是非空约束不能用于表级约束

#### 1. 非空约束not null

#### 2. 唯一性约束unique

> `unique`约束的字段，具有唯一性，不可重复，**但可以为null** [todo][]
>
> 1. 表级约束范例：`[constraint] [约束名称] UNIQUE(字段名)`
>
>    ![image-20230327172907353](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230327172907353.png)
>
> 2. 联合约束范例：表示两个或以上字段同时与另一条记录相等，则报错
>
>    如：
>
>    ![1679909495928](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/1679909495928.png)
>
>    ![1679909517879](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/1679909517879.png)

#### 3. 主键约束primary key

> 在实际开发中，往往会**要求表的设计一定要有主键**（仅有一个），并且往往会使**用与业务无关的自增ID作为主键**（第6章讲到），**不建议使用复合主键**
>
> - •主键效果和”not null unique”约束相同，但主键约束除了可以做到”not null unique”效果之外，还会默认添加”**索引—index**”（重点，讲到B树时会讲到），可加速检索
>
> - 单一主键
>
>   ![image-20230327173739864](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230327173739864.png)
>
> - 复合主键
>
>   ![image-20230327173813104](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230327173813104.png)
>
> - `auto_increment`
>
>   在MySQL数据库提供了一个自增的数字`auto_increment`，专门用来自动生成主键值，主键值不用用户维护，自动生成，自增数从1开始，以1递增

#### 4. 外键约束foreign key

> - 用于维护两个表（**主表、引用表**）之间数据的一致性
>
> - 下面是一个例子：
>
>   ![image-20230327174251367](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230327174251367.png)
>
>   要注意的是创建的先后顺序！主表必须先创建
>
> - 新建表时增加外键： `[CONSTRAINT] [外键约束名称] FOREIGN KEY(外键字段名) REFERENCES 主表名(主键字段名)`
>
> - 一些注意事项：
>
>   - 外键值可以为null（如果没有设置not null就可以）
>
>     需要注意的是，如果外键列被设置为null，它将不会参与到关联查询中，因为它不再指向任何其他表中的记录。
>
>   - 外键字段去引用一张表的某个字段的时候，被引用的字段必须具有unique约束。
>
>     因为**外键约束的目的是确保表之间的数据关系的完整性**。如果外键引用的字段不具有unique约束，那么就可能会出现多个记录引用同一个被引用表中的记录的情况。
>
>   - 创建先创建主表，后创建引用表
>
>   - 删除先删除引用表数据，否则删除不了主表
>
>   - 插入先插入主表数据

#### 默认约束default

> 默认值约束通常用在已经设置了非空约束的列，这样能够防止数据表在录入数据时出现错误
>
> - `<字段名> <数据类型> DEFAULT <默认值>;`
>
> - 例子：
>
>   创建数据表 t_dept，部门位置location默认为 Beijing
>
>   ```mysql
>   create table t_dept (
>      id int (11) primary key,
>      location varchar(20) default 'Beijing'
>   )
>   ```

#### Alter添加约束

> - 外键
>
>   添加：`alter table <表名> add constraint <外键名)>foreign key<外键字段名> references <外表表名(外表的主键字段名)>;`
>
>   删除：`alter table <tableName> drop foreign key <foreignKeyName>;`
>
> - 主键
>
>   添加：`alter table <tableName> add primary key(<id>)`
>
>   删除：`alter table <tableName> drop primary key;`

### Alter修改语句

```mysql
ALTER TABLE <表名> { 
ADD COLUMN <列名> <类型>						添加新的字段
| CHANGE COLUMN <旧列名> <新列名> <新列类型>		更改字段名称
| MODIFY COLUMN <列名> <类型>					修改字段类型
| DROP COLUMN <列名>							  删除字段
| RENAME TO <新表名>							 表格重命名
}
```

### Drop删除语句

```mysql
DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 ...]
```

### Truncate清除语句

```mysql
TRUNCATE TABLE name
```

>TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。

## 数据操作语句DML

### 增加语句insert

```mysql
INSERT INTO table_name [( 字段1, 字段2,...字段N )]
            VALUES ( value1, value2,...valueN );
```

> **字段和value一一对应**

### 更新语句update

```mysql
UPDATE table_name SET column1=expr1[, column2=expr2...]
			[WHERE where_condition]
```

> column表示字段名，expr表示要插入的值或表达式，where子句代表更新数据的满足条件

**如果update语句不加where子句，则表示所有的行都更新！**

### 删除语句delete

```mysql
DELETE FROM tbl_name
          [WHERE where_condition]
          [ORDER BY ...]
          [LIMIT row_count]
```

>`tbl_name`关键词代表删除数据的目标表；
>
>`where子句`代表被删除数据的满足条件，如果没有where子句则代表所有表数据都删除；
>
>`order by子句`代表删除数据的顺序；
>
>`limit子句`代表被删除数据的行数限制。

## 数据查询语句DQL

### 单表查询

![image-20230416194554496](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230416194554496.png)

#### where子句

![image-20230416203031401](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230416203031401.png)

#### order by子句

用于给查询结果按照某些字段排序，默认是升序，降序用DESC

```sql
select * from student order by age
```

#### group by子句

用于表示将查询结果根据哪个字段进行分组聚合，上文已经提到了聚合函数（`aggregate_function`）

> 注意：一旦查询语句中出现`group by`子句，那么在查询`select`子句中只能出现`group by`子句出现的字段和用聚合函数`aggregate_function`的字段，其他字段均不能出现！
>
> 这是因为`group by`是根据什么聚合的意思，查询结果是一个类似小计的结果

- 语法：

```sql
select column_name, aggregate_function(column_name)
from table_name
where column_name operator value
group by column_name;

# eg. select count(*), department from student group by department
```

#### having子句

相当于条件筛选，但它与`where`筛选不同，`having`是对于`group by`对象进行筛选。

```sql
select count(*), department from student group by department having count(*) > 20
```

### 多表查询—连接查询

表连接的约束条件可以有三种方式：`where`、`on`、`using`（用得少且条件特殊）

1. `where`：关联条件写在`where`后面

   ```sql
   SELECT 姓名, 年龄,成绩 FROM S, SC where S.学号 = SC.学号
   ```

2. `on`：只能和`join`一起使用，关联条件写在`on`后面

   ```sql
   SELECT 姓名, 年龄, 成绩 FROM S JOIN SC ON S.学号 = SC.学号
   ```

连接查询的详细过程：

（1）形成笛卡尔乘积的临时表

（2）从笛卡尔积临时表中提取出复合条件的数据

#### JOIN连接查询

|            连接类型            |                         连接类型说明                         |
| :----------------------------: | :----------------------------------------------------------: |
|    [INNER] JOIN （内连接）     |               结果为两个联接表中匹配行的联接。               |
| LEFT [OUTER] JOIN（左外连接）  | 结果包括“左”表（出现在 JOIN 子句的最左边）中的所有行。不包括右表中的不匹配行。 |
| RIGHT [OUTER] JOIN（右外连接） | 结果包括“右”表（出现在JOIN 子句的最右边）中的所有行。不包括左表中的不匹配行。 |
|  FULL [OUTER] JOIN（全连接）   |        结果包括所有联接表中的所有行，不论它们是否匹配        |
|            自我连接            | 本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的表进行连接 |

![image-20230416231614265](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230416231614265.png)

##### 内连接

![image-20230416231812001](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230416231812001.png)

##### 左外连接

![image-20230416231843925](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230416231843925.png)

##### 右外连接

![image-20230416231906977](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230416231906977.png)

##### 全连接

![image-20230416232114200](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230416232114200.png)

##### 另外三种特殊连接

![image-20230416232355292](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230416232355292.png)

1. ```sql
   SELECT * FROM TableA RIGHT OUTER JOIN TableB ON TableA.name = TableB.name
   WHERE TableA.name is null.
   ```

2. ```sql
   SELECT * FROM TableA LEFT OUTER JOIN TableB ON TableA.name = TableB.name
   WHERE TableB.name is null.
   ```

3. ```sql
   SELECT * FROM TableA RIGHT OUTER JOIN TableB ON TableA.name = TableB.name WHERE TableA.name is null 
   union 
   SELECT * FROM TableA LEFT OUTER JOIN TableB ON TableA.name = TableB.name WHERE TableB.name is null
   ```

### 自连接

虽然在join连接下，但是很重要，首先介绍`AS`关键字

#### AS关键字

![image-20230416232800758](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230416232800758.png)

> 注意`AS`可写可不写

#### 自我关联

- 由来：

  在数据库中，树形组织架构，每个节点中存储的内容有当前节点的`id`、节点的内容、以及对应上一个节点的`id`

  如下图所示

  ![image-20230416233045533](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230416233045533.png)

  在这种设计之下的表格该如何进行查询（1）查询张经理属下的所有主管、（2）王主管属下的所有工人

  因而引出自我关联，表A.id = 表B.pri_id（这里的表A、B都对应上面同一个表）

例题：

![image-20230416234205267](https://picgo-picture-storage.oss-cn-guangzhou.aliyuncs.com/img/image-20230416234205267.png)

### 嵌套查询

